<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>FreeFlowXR – Panel Deweloperski</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Inter', sans-serif;
        }

        nav {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 1000;
            padding: 20px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8), transparent);
            box-sizing: border-box;
        }

        .logo {
            color: white;
            font-weight: bold;
            font-size: 20px;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo img {
            height: 30px;
        }

        .menu {
            display: flex;
            gap: 30px;
        }

        .menu a {
            color: rgba(255, 255, 255, 0.7);
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            transition: color 0.3s ease;
        }

        .menu a:hover,
        .menu a.active {
            color: white;
        }

        .back-btn {
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            color: white;
            text-decoration: none;
            font-size: 14px;
            transition: all 0.3s;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: white;
        }

        @media (max-width: 768px) {
            nav {
                padding: 15px;
                flex-direction: column;
                gap: 15px;
                background: linear-gradient(to bottom, rgba(0, 0, 0, 0.9), transparent);
            }

            .menu {
                width: 100%;
                justify-content: center;
                gap: 20px;
            }

            .logo {
                margin-bottom: 5px;
            }

            /* Ukrywamy panel deweloperski na mobile, bo zasłania widok */
            .lil-gui {
                display: none !important;
            }
        }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.161/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161/examples/jsm/" } }
    </script>
</head>

<body>
    <nav>
        <a href="/" class="logo">
            <img src="/logo_header.png" alt="Logo">
        </a>
        <div class="menu">
            <a href="#" class="active">Technologia</a>
            <a href="/?view=map">Maps plan</a>
            <a href="/contact">Kontakt</a>
        </div>
        <a href="/?view=map" class="back-btn">← Wróć do Mapy</a>
    </nav>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // 1. Inicjalizacja GUI
        const gui = new GUI({ title: 'Panel Deweloperski' });

        // 2. Scena, Kamera, Renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        // scene.fog usunięta dla efektu void
        const clock = new THREE.Clock(); // Główny zegar sceny

        // Dostosowanie FOV dla mobile (szerszy kąt w pionie)
        const isMobile = window.innerWidth < 768;
        const initialFov = isMobile ? 60 : 35;

        const camera = new THREE.PerspectiveCamera(initialFov, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 2.485996, 6.13);
        camera.rotation.x = -0.38;

        // Korekta pozycji kamery na mobile (trochę dalej)
        if (isMobile) {
            camera.position.set(0, 2.0, 9.0);
            camera.rotation.x = -0.15;
        }

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Ograniczenie DPR do 2.0 (wyższa jakość)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.6;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // 3. Kontrolery i Post-processing
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1.2, 0);
        controls.enableDamping = true;
        controls.minDistance = 2;
        controls.maxDistance = 8;
        controls.maxPolarAngle = Math.PI * 0.85;
        controls.minPolarAngle = Math.PI * 0.1;

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 1;
        bloomPass.strength = 1.833;
        bloomPass.radius = 0;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // 4. Światła
        RectAreaLightUniformsLib.init();

        const keyLight = new THREE.RectAreaLight(0xffffff, 0, 2, 4);
        keyLight.position.set(-2.5, 2.5, 2.5);
        keyLight.lookAt(0, 1.0, 0);
        scene.add(keyLight);

        const fillLight = new THREE.SpotLight(0xffffff, 0);
        fillLight.position.set(3, 2, 2);
        fillLight.angle = Math.PI / 4;
        fillLight.penumbra = 1;
        fillLight.castShadow = true;
        scene.add(fillLight);

        const rimLight = new THREE.SpotLight(0x3ac8ff, 2);
        rimLight.position.set(0, 2.2, -3);
        rimLight.lookAt(0, 1.0, 0);
        rimLight.penumbra = 0.5;
        scene.add(rimLight);

        // bounceLight już jest zadeklarowane później, ale tutaj były definicje innych świateł.
        // Czekaj, bounceLight jest osobno w linii 134. Tutaj zmieniamy tylko key, fill, rim.

        const hemiLight = new THREE.HemisphereLight(0x222222, 0x000000, 0);
        scene.add(hemiLight);

        // 5. Obiekty Sceny
        const textureLoader = new THREE.TextureLoader();

        // Podłoga
        const floorGeo = new THREE.PlaneGeometry(10, 10);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4, metalness: 0.2 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Pokój i sufit usunięte (Void Stage)

        // Ekran
        const screenWidth = 4.8, screenHeight = 2.7, screenDepth = 1.2;
        const screenGeo = new THREE.BoxGeometry(screenWidth, screenHeight, screenDepth);
        const treeTexture = textureLoader.load('assets/textures/FREEFLOW_LOGO.png');
        treeTexture.colorSpace = THREE.SRGBColorSpace;
        const panelMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.6, metalness: 0.3 });
        const screenFrontMat = new THREE.MeshBasicMaterial({ map: treeTexture, transparent: true });
        const screenMaterials = [panelMat, panelMat, panelMat, panelMat, screenFrontMat, panelMat];
        const screen = new THREE.Mesh(screenGeo, screenMaterials);
        // Obniżona pozycja ekranu, dolna krawędź na 0.4
        // Y = 0.4 (podest) + screenHeight/2 (1.35) = 1.75
        screen.position.set(0, 1.75, -2.5 - screenDepth / 2);
        scene.add(screen);

        const bounceLight = new THREE.RectAreaLight(0x2fc7ff, 4.38, screenWidth, screenHeight);
        bounceLight.position.set(0, 1.75, -2.4); // Zaktualizowana pozycja światła
        bounceLight.lookAt(0, 1.0, 2.0);
        bounceLight.rotation.y = Math.PI;
        scene.add(bounceLight);

        // === SZKLANY PODEST ===
        const platformWidth = screenWidth;
        const platformDepth = 3.0;
        const platformHeight = 0.4; // Podwyższony podest
        const platformGeo = new THREE.BoxGeometry(platformWidth, platformHeight, platformDepth);

        const platformMat = new THREE.MeshStandardMaterial({
            color: 0x080808, // Prawie czarny, lekko widoczny
            roughness: 0.8,
            metalness: 0.2
        });

        const platform = new THREE.Mesh(platformGeo, platformMat);
        // Pozycja: Środek podestu = -2.5 + 1.5 = -1.0 (styka się z ekranem)
        platform.position.set(0, platformHeight / 2, -1.0);
        scene.add(platform);

        // === SYSTEM CZĄSTECZKOWY (Hologram) ===


        let particleSystem;
        // const clock usuwamy stąd


        function initParticleText() {
            const isMobile = window.innerWidth < 768;
            const pointMultiplier = isMobile ? 400.0 : 300.0;
            const alphaBoost = isMobile ? "0.8" : "1.0"; // Lekkie rozjaśnienie

            const vertexShader = `
            uniform float uTime, uProgress, uShineProgress, uGlobalAlpha; uniform vec2 uMouse;
            attribute vec3 aRandomPosition; attribute float aSize;
            varying vec3 vColor; varying float vAlpha;
            void main() {
                float t = smoothstep(0.0, 1.0, uProgress);
                vec3 currentPos = mix(aRandomPosition, position, t);
                
                // Interakcja z myszą (delikatna)
                if (uProgress > 0.9) { 
                    float dist = distance(currentPos.xz, uMouse * 4.0);
                    if (dist < 1.0) {
                        currentPos.y += (1.0 - dist) * 0.1;
                    }
                }

                vec4 mvPosition = modelViewMatrix * vec4(currentPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                // Skalowanie dynamiczne
                gl_PointSize = aSize * (${pointMultiplier.toFixed(1)} / -mvPosition.z);
                
                // Kolory
                float mixFactor = (position.z + 2.0) * 0.25;
                vec3 cyan = vec3(0.0, 1.0, 1.0);
                vec3 white = vec3(1.0, 1.0, 1.0);
                vec3 baseColor = mix(cyan, white, mixFactor);
                
                // Efekt Shine (przejście światła)
                float sweepPos = mix(-5.0, 5.0, uShineProgress); // Dopasowane do skali podestu
                float distX = abs(currentPos.x - sweepPos);
                float shine = smoothstep(1.0, 0.0, distX);
                vec3 gold = vec3(1.0, 0.85, 0.4);
                
                vColor = baseColor + (gold * shine * 1.2);
                vAlpha = smoothstep(0.0, 0.2, uProgress) * uGlobalAlpha * ${alphaBoost};
            }`;

            const fragmentShader = `
            varying vec3 vColor; varying float vAlpha;
            void main() {
                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = length(coord);
                if (dist > 0.5) discard;
                float strength = pow(1.0 - (dist * 2.0), 2.0);
                gl_FragColor = vec4(vColor, strength * vAlpha);
            }`;

            const canvas = document.createElement('canvas');
            canvas.width = 2048; canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = 'bold 350px sans-serif';
            ctx.fillText("Free Flow", canvas.width / 2, canvas.height / 2 - 200);
            ctx.fillText("Mind XR", canvas.width / 2, canvas.height / 2 + 200);

            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height), data = imgData.data;
            const targetPositions = [], randomPositions = [], sizes = [], scale = 0.0028;

            for (let y = 0; y < canvas.height; y += 4) {
                for (let x = 0; x < canvas.width; x += 4) {
                    const i = (y * canvas.width + x) * 4;
                    if (data[i + 3] > 128) {
                        // Mapowanie na płaszczyznę XZ (podest)
                        const pX = (x - canvas.width / 2) * scale;
                        const pZ = (y - canvas.height / 2) * scale;
                        const pY = 0.45; // Bezpieczna wysokość nad podestem

                        targetPositions.push(pX, pY, pZ);

                        // Losowe pozycje startowe (rozsypane w powietrzu nad podestem)
                        randomPositions.push(
                            (Math.random() - 0.5) * 5.0,
                            1.0 + Math.random() * 3.0,
                            (Math.random() - 0.5) * 5.0
                        );
                        sizes.push(Math.random() * 0.03 + 0.01);
                    }
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(targetPositions, 3));
            geometry.setAttribute('aRandomPosition', new THREE.Float32BufferAttribute(randomPositions, 3));
            geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                vertexShader, fragmentShader,
                uniforms: {
                    uTime: { value: 0 },
                    uProgress: { value: 0 },
                    uShineProgress: { value: 0 },
                    uGlobalAlpha: { value: 1.0 },
                    uMouse: { value: new THREE.Vector2(0, 0) }
                },
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            // Poprawa orientacji (odwrócenie rotacji)
            particleSystem.rotation.x = 0.4;
            particleSystem.position.set(0, -1.2, 2.0); // Przesunięte w dół i do przodu
            scene.add(particleSystem);
        }

        initParticleText();


        // Tło (Niebo) usunięte (Void Stage)

        // === AWATAR PARALLAX (Clean Transparency) ===
        const avatarTexture = textureLoader.load('assets/textures/amber_new.png');
        avatarTexture.colorSpace = THREE.SRGBColorSpace;
        avatarTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();

        // Zmniejszamy wysokość o 5% zgodnie z życzeniem (jeśli było takie, tu standard 1.7m)
        const avatarHeight = 1.7;
        // Obliczymy szerokość dynamicznie po załadowaniu, startujemy z 1.0

        const avatarGeo = new THREE.PlaneGeometry(1, 1);
        const avatarMat = new THREE.MeshBasicMaterial({
            map: avatarTexture,
            transparent: true,
            opacity: 0, // Startujemy od 0
            side: THREE.DoubleSide,
            depthWrite: false // Ważne dla czystej transparencji na tle
        });

        const avatar = new THREE.Mesh(avatarGeo, avatarMat);
        avatar.position.set(0, 0.4 + avatarHeight / 2, -1.0);

        // Grupa dla efektu paralaksy (pozwala na precyzyjne obracanie)
        const avatarGroup = new THREE.Group();
        avatarGroup.add(avatar);
        scene.add(avatarGroup);

        // Dopasowanie proporcji po załadowaniu
        function updateAvatarAspect() {
            const image = avatarTexture.image;
            if (image && image.width && image.height) {
                const aspect = image.width / image.height;
                const width = avatarHeight * aspect;
                avatar.geometry.dispose();
                avatar.geometry = new THREE.PlaneGeometry(width, avatarHeight);
                console.log("Avatar aspect updated:", aspect, width);
            }
        }

        avatarTexture.onload = updateAvatarAspect;

        // Check if already loaded (cached)
        if (avatarTexture.image) updateAvatarAspect();

        const mouse = new THREE.Vector2();
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        // 6. Konfiguracja GUI
        const visibilityFolder = gui.addFolder('Intensywność Elementów');

        // Logika restartu animacji
        let animationStartTime = 0;
        const animControl = {
            restart: () => {
                animationStartTime = clock.getElapsedTime();
                if (particleSystem) {
                    particleSystem.material.uniforms.uGlobalAlpha.value = 1.0;
                }
                avatarMat.opacity = 0;
            }
        };
        gui.add(animControl, 'restart').name('▶ Restart Animacji');

        const avatarFolder = gui.addFolder('Ustawienia Awatara');
        // Opcjonalnie: można dodać kontrolę skali lub jasności, na razie puste lub usunięte
        // avatarFolder.add(avatarMat, 'opacity', 0, 1).name('Przezroczystość (Debug)');

        visibilityFolder.add({ logoOpacity: 100 }, 'logoOpacity', 0, 100, 1).name('Logo (Drzewo) %').onChange((value) => {
            screenFrontMat.opacity = value / 100;
            screen.visible = value > 0;
        });

        const textParams = {
            duration: 1000,
            fadeOutStart: 12.01,
            manualFade: false
        };

        visibilityFolder.add(textParams, 'fadeOutStart', 0, 20).name('Zniknij po (s)');

        visibilityFolder.add({
            toggle: () => {
                if (!particleSystem) return;
                textParams.manualFade = !textParams.manualFade;
            }
        }, 'toggle').name('Pokaż/Ukryj Napis');

        const lightFolder = gui.addFolder('Oświetlenie Studyjne');
        lightFolder.add(keyLight, 'intensity', 0, 5).name('Światło Kluczowe');
        lightFolder.add(fillLight, 'intensity', 0, 2).name('Światło Wypełniające');
        lightFolder.add(rimLight, 'intensity', 0, 2).name('Światło Tylne (Rim)');
        lightFolder.add(bounceLight, 'intensity', 0, 10).name('Odbicie od Ekranu');
        lightFolder.add(hemiLight, 'intensity', 0, 1).name('Światło Otoczenia');

        const bloomFolder = gui.addFolder('Efekt Poświaty (Bloom)');
        bloomFolder.add(bloomPass, 'threshold', 0, 1).name('Próg Jasności');
        bloomFolder.add(bloomPass, 'strength', 0, 5).name('Intensywność');
        bloomFolder.add(bloomPass, 'radius', 0, 2).name('Promień Rozmycia');

        const camFolder = gui.addFolder('Ustawienia Kamery');
        camFolder.add(camera.position, 'y', 0.5, 10).name('Wysokość');
        camFolder.add(camera.position, 'z', 2, 8).name('Oddalenie');
        camFolder.add(camera.rotation, 'x', -0.5, 0.5).name('Kąt Nachylenia');

        // Pętla animacji
        function animate() {
            requestAnimationFrame(animate);
            const globalTime = clock.getElapsedTime();
            const time = globalTime - animationStartTime; // Czas lokalny dla animacji

            if (particleSystem) {
                particleSystem.material.uniforms.uTime.value = time;
                particleSystem.material.uniforms.uMouse.value.copy(mouse);

                // Animacja wejścia (0 do 2.5s)
                let progress = Math.min(time * 0.4, 1.0);
                particleSystem.material.uniforms.uProgress.value = progress;

                // Efekt Shine (cykliczny co jakiś czas)
                if (progress >= 1.0) {
                    // Shine co 5 sekund
                    let shineTime = (time - 2.5) % 5.0;
                    if (shineTime < 1.0) {
                        particleSystem.material.uniforms.uShineProgress.value = shineTime;
                    } else {
                        particleSystem.material.uniforms.uShineProgress.value = -1.0; // poza zakresem
                    }
                }

                // Animacja ZNIKANIA (Fade Out) kontrolowana przez suwak
                let targetAlpha = 1.0;
                if (time > textParams.fadeOutStart && !textParams.manualFade) {
                    targetAlpha = 0.0;
                } else if (textParams.manualFade) {
                    targetAlpha = 0.0;
                }

                particleSystem.material.uniforms.uGlobalAlpha.value = THREE.MathUtils.lerp(
                    particleSystem.material.uniforms.uGlobalAlpha.value,
                    targetAlpha,
                    0.05
                );

                // --- LOGIKA AWATARA ---
                // Jeśli napis zniknął (targetAlpha == 0 i alpha jest bliska 0) LUB minął czas
                // Przyjmijmy prostą logikę czasową: FadeOutStart + 1.0s

                if (time > textParams.fadeOutStart + 1.0) {
                    // Pojawianie się awatara
                    avatarMat.opacity = THREE.MathUtils.lerp(avatarMat.opacity, 1.0, 0.05);
                } else {
                    // Ukrywanie awatara
                    avatarMat.opacity = THREE.MathUtils.lerp(avatarMat.opacity, 0.0, 0.1);
                }
            }

            controls.update();
            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>