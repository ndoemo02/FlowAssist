<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>FreeFlowXR ‚Äì Panel Deweloperski</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Inter', sans-serif;
        }

        nav {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 1000;
            padding: 20px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8), transparent);
            box-sizing: border-box;
        }

        .logo {
            color: white;
            font-weight: bold;
            font-size: 20px;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo img {
            height: 30px;
        }

        .menu {
            display: flex;
            gap: 30px;
        }

        .menu a {
            color: rgba(255, 255, 255, 0.7);
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            transition: color 0.3s ease;
        }

        .menu a:hover,
        .menu a.active {
            color: white;
        }

        .back-btn {
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            color: white;
            text-decoration: none;
            font-size: 14px;
            transition: all 0.3s;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: white;
        }

        #debug-toggle {
            display: none;
        }

        @media (max-width: 768px) {
            nav {
                padding: 15px;
                flex-direction: column;
                gap: 15px;
                background: linear-gradient(to bottom, rgba(0, 0, 0, 0.9), transparent);
            }

            .menu {
                width: 100%;
                justify-content: center;
                gap: 20px;
            }

            .logo {
                margin-bottom: 5px;
            }

            /* Ukrywamy panel deweloperski na mobile, bo zas≈Çania widok */
            /* Ukrywamy panel deweloperski na mobile DOMY≈öLNIE, ale pozwalamy go w≈ÇƒÖczyƒá */
            #gui-container {
                display: none;
                /* Bƒôdzie sterowane przez JS */
                position: fixed;
                top: 0;
                right: 0;
                z-index: 3000;
            }

            /* Wymuszamy, ≈ºeby dzieci gui-container (czyli lil-gui) by≈Çy widoczne */
            #gui-container .lil-gui {
                max-height: 90vh;
                overflow-y: auto;
                /* Override default lil-gui fixed positioning if needed, though container handles it */
                position: static !important;
            }

            #debug-toggle {
                position: fixed;
                bottom: 20px;
                left: 20px;
                width: 40px;
                height: 40px;
                background: rgba(0, 0, 0, 0.6);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 50%;
                color: white;
                font-size: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 2000;
                cursor: pointer;
            }
        }
    </style>
    <div id="debug-toggle">‚öôÔ∏è</div>
    <div id="gui-container"></div>
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.161/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161/examples/jsm/", "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.5/index.js" } }
    </script>
</head>

<body>
    <nav>
        <a href="/" class="logo">
            <img src="/logo_header.png" alt="Logo">
        </a>
        <div class="menu">
            <a href="#" class="active">Technologia</a>
            <a href="/dev/v5">Studio V5</a>
            <a href="/?view=map">Maps plan</a>
            <a href="/contact">Kontakt</a>
        </div>
        <a href="/dev/v5" class="back-btn">‚Üí Studio V5</a>
    </nav>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import gsap from 'gsap';

        // 1. Inicjalizacja GUI
        // 1. Inicjalizacja GUI w kontenerze
        const guiContainer = document.getElementById('gui-container');
        const gui = new GUI({ title: 'Panel Deweloperski', container: guiContainer, width: 300 });

        // Debug Toggle Logic
        const debugToggle = document.getElementById('debug-toggle');
        let isDebugVisible = false;

        if (window.innerWidth < 768) {
            debugToggle.style.display = 'flex';
            guiContainer.style.display = 'none'; // Ensure hidden on mobile start
        } else {
            // Desktop: ensure visible
            guiContainer.style.display = 'block';
            guiContainer.style.position = 'absolute';
            guiContainer.style.top = '0';
            guiContainer.style.right = '0';
        }

        debugToggle.addEventListener('click', () => {
            isDebugVisible = !isDebugVisible;
            guiContainer.style.display = isDebugVisible ? 'block' : 'none';
        });

        // === PRIORITY DEBUG BUTTONS (Added first to ensure visibility) ===
        const camFolder = gui.addFolder('Ustawienia Kamery (DEBUG)');
        // Will populate this folder after camera is created


        // 2. Scena, Kamera, Renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        // scene.fog usuniƒôta dla efektu void
        const clock = new THREE.Clock(); // G≈Ç√≥wny zegar sceny

        // Dostosowanie FOV dla mobile (szerszy kƒÖt w pionie)
        const isMobile = window.innerWidth < 768;
        const initialFov = isMobile ? 60 : 35;

        const camera = new THREE.PerspectiveCamera(initialFov, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 2.485996, 6.13);
        camera.rotation.x = -0.38;

        // Korekta pozycji kamery na mobile (wy≈ºej i dalej)
        if (isMobile) {
            camera.position.set(0, 3.5, 10.0);
            camera.rotation.x = -0.25;
        }

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Ograniczenie DPR do 2.0 (wy≈ºsza jako≈õƒá)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.6;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // 3. Kontrolery i Post-processing
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1.2, 0);
        controls.enableDamping = true;
        controls.minDistance = 2;
        controls.maxDistance = 8;
        controls.maxPolarAngle = Math.PI * 0.85;
        controls.minPolarAngle = Math.PI * 0.1;

        // === POPULATE CAMERA DEBUG (Now that camera & controls exist) ===
        const debugParams = {
            logCoords: () => {
                const info = `
Camera POS: x:${camera.position.x.toFixed(2)}, y:${camera.position.y.toFixed(2)}, z:${camera.position.z.toFixed(2)}
Target LOOK: x:${controls.target.x.toFixed(2)}, y:${controls.target.y.toFixed(2)}, z:${controls.target.z.toFixed(2)}
                `;
                console.log(info);
                alert(info);
            }
        };

        camFolder.add(camera.position, 'x', -10, 10).name('Cam X').listen();
        camFolder.add(camera.position, 'y', 0, 20).name('Cam Y').listen();
        camFolder.add(camera.position, 'z', 0, 25).name('Cam Z').listen();

        camFolder.add(controls.target, 'x', -5, 5).name('LookAt X').listen().onChange(() => controls.update());
        camFolder.add(controls.target, 'y', -5, 10).name('LookAt Y').listen().onChange(() => controls.update());
        camFolder.add(controls.target, 'z', -10, 10).name('LookAt Z').listen().onChange(() => controls.update());

        camFolder.add(debugParams, 'logCoords').name('üìã LOG COORDINATES');
        camFolder.open();

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 1;
        bloomPass.strength = 1.833;
        bloomPass.radius = 0;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // 4. ≈öwiat≈Ça
        RectAreaLightUniformsLib.init();

        const keyLight = new THREE.RectAreaLight(0xffffff, 0, 2, 4);
        keyLight.position.set(-2.5, 2.5, 2.5);
        keyLight.lookAt(0, 1.0, 0);
        scene.add(keyLight);

        const fillLight = new THREE.SpotLight(0xffffff, 0);
        fillLight.position.set(3, 2, 2);
        fillLight.angle = Math.PI / 4;
        fillLight.penumbra = 1;
        fillLight.castShadow = true;
        scene.add(fillLight);

        const rimLight = new THREE.SpotLight(0x3ac8ff, 2);
        rimLight.position.set(0, 2.2, -3);
        rimLight.lookAt(0, 1.0, 0);
        rimLight.penumbra = 0.5;
        scene.add(rimLight);

        // bounceLight ju≈º jest zadeklarowane p√≥≈∫niej, ale tutaj by≈Çy definicje innych ≈õwiate≈Ç.
        // Czekaj, bounceLight jest osobno w linii 134. Tutaj zmieniamy tylko key, fill, rim.

        const hemiLight = new THREE.HemisphereLight(0x222222, 0x000000, 0);
        scene.add(hemiLight);

        // 5. Obiekty Sceny
        const textureLoader = new THREE.TextureLoader();

        // Pod≈Çoga
        const floorGeo = new THREE.PlaneGeometry(10, 10);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4, metalness: 0.2 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Pok√≥j i sufit usuniƒôte (Void Stage)

        // Ekran (Drzewo Video w jako≈õci HD) - PODWY≈ªSZONY DLA PIONOWEGO WIDEO
        const screenWidth = 4.8, screenHeight = 6.4, screenDepth = 1.2;

        const screenGeo = new THREE.BoxGeometry(screenWidth, screenHeight, screenDepth);

        // === WIDEO LOGO (Drzewo) ===
        const logoVideo = document.createElement('video');
        logoVideo.src = '/assets/video/drzewo%20video.mp4';
        logoVideo.loop = true;
        logoVideo.muted = true;
        logoVideo.playsInline = true;
        logoVideo.crossOrigin = 'anonymous';
        logoVideo.play();

        const treeTexture = new THREE.VideoTexture(logoVideo);
        treeTexture.minFilter = THREE.LinearFilter;
        treeTexture.magFilter = THREE.LinearFilter;
        treeTexture.colorSpace = THREE.SRGBColorSpace;

        // Zapobieganie rozciƒÖganiu na ca≈ÇƒÖ szeroko≈õƒá (centrowanie pionowego wideo)
        // Zapobieganie rozciƒÖganiu na ca≈ÇƒÖ szeroko≈õƒá (centrowanie pionowego wideo - tryb COVER)
        logoVideo.addEventListener('loadedmetadata', () => {
            const videoAspect = logoVideo.videoWidth / logoVideo.videoHeight;
            const screenAspect = screenWidth / screenHeight;

            // COVER Logic: Scale until both dimensions cover the screen.
            // One repeat will be 1, the other < 1 (cropping).
            if (videoAspect < screenAspect) {
                // Video is narrower than screen (e.g. Portrait on Landscape)
                // We match Width, crop Height? No.
                // If video is 0.5, screen is 1.0.
                // To cover, we must match Width? No, if we match width, height is 2.0 (covers).
                // So repeat.x = 1.
                // repeat.y = screenAspect / videoAspect ???
                // Wait.
                // If Video 1x2, Screen 1x1. Match Width -> Video fits X. Height is 2x screen.
                // We see 1/2 of texture height.
                // repeat.y = 0.5 = videoAspect / screenAspect (0.5 / 1.0). 
                // Wait, logic above said repeat.y = videoAspect/screenAspect.
                // Let's verification:
                // screenAspect/videoAspect = 1/0.5 = 2.0.
                // videoAspect/screenAspect = 0.5/1 = 0.5.
                // We want 0.5. 
                // So: repeat.x = 1; repeat.y = videoAspect / screenAspect;
                // BUT wait.
                // Case: VideoAspect < ScreenAspect. 
                // e.g. Video 0.5, Screen 1.0.
                // My logic says repeat.y = 0.5.

                // Let's re-read the previous code block.
                // if (videoAspect < screenAspect) { ... repeatX = screenAspect / videoAspect ... }
                // previous code: 1.0 / 0.5 = 2.0. repeat.x = 2.0.
                // That was "Contain" (roughly, or rather 'Fill Width and stretch height?').
                // Actually if repeat.x=2, we see 2 copies of texture width?
                // No.

                // Let's stick to the trusted formula for COVER:
                if (screenAspect > videoAspect) {
                    // Screen is wider than video. Fit Width (scale up video). Crop Height (Top/Bottom).
                    // Actually: If screen is wider, we must match WIDTH to cover?
                    // Video 100x100 (1.0). Screen 200x100 (2.0).
                    // We must scale Video to 200x200.
                    // We display full Width of video? No.
                    // We display 200 width. Texture has 100.
                    // We see only HALF of the texture height? No.
                    // We see full texture width?
                    // If we map 0..1 mesh to 0..1 texture.
                    // Mesh is 2:1. Texture is 1:1.
                    // Image looks stretched wide.
                    // We want to correct aspect.
                    // We want to show LESS height? or LESS width?
                    // To keep aspect 1:1 on a 2:1 screen...
                    // We must zoom in.
                    // We show full width (1.0).
                    // We show 0.5 height? No.
                    // If we show full width (200 screen units), and we want 1:1 aspect.
                    // Height should be 200 screen units. But screen is only 100.
                    // So we show 100/200 = 0.5 of the image height.
                    // So repeat.x = 1. repeat.y = 0.5.
                    // 0.5 = videoAspect (1) / screenAspect (2).
                    // Formula: `repeat.x = 1`, `repeat.y = videoAspect / screenAspect`.

                    treeTexture.repeat.set(1, videoAspect / screenAspect);
                    treeTexture.offset.set(0, (1 - (videoAspect / screenAspect)) / 2);
                } else {
                    // Screen is taller than video (or equal).
                    // e.g. Screen 1:2 (0.5). Video 1:1 (1.0).
                    // We must match Height (scale video to height 200).
                    // Video becomes 200x200.
                    // Screen is 100x200.
                    // We show full Height (1.0).
                    // We show 100/200 = 0.5 of image width.
                    // repeat.y = 1.
                    // repeat.x = screenAspect / videoAspect. (0.5 / 1.0 = 0.5).

                    treeTexture.repeat.set(screenAspect / videoAspect, 1);
                    treeTexture.offset.set((1 - (screenAspect / videoAspect)) / 2, 0);
                }
            } else {
                // videoAspect >= screenAspect.
                // Handled in the 'else' of my thought process, but let's structure code properly.

                // Simplified:
                const factorX = screenAspect / videoAspect;
                const factorY = videoAspect / screenAspect;

                if (factorX > 1) { // Screen wider than video -> fit width, crop height?
                    // Wait. If screen wider, we need to match Width? 
                    // No, if screen is WIDER, we match WIDTH to cover.
                    // If we match Height, we would have black bars on sides (Contain).
                    // So yes, match width.

                    // repeat.x = 1.
                    // repeat.y = factorY. (0.5 example).
                    treeTexture.repeat.set(1, factorY);
                    treeTexture.offset.set(0, (1 - factorY) / 2);
                } else {
                    // Screen taller/narrower.
                    // Match Height. Crop Width.
                    // repeat.y = 1.
                    // repeat.x = factorX.
                    treeTexture.repeat.set(factorX, 1);
                    treeTexture.offset.set((1 - factorX) / 2, 0);
                }
            }
        });

        // BasicMaterial zapewnia brak cieniowania (samo≈õwiecenie) = realna jako≈õƒá grafiki
        const panelMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const screenFrontMat = new THREE.MeshBasicMaterial({
            map: treeTexture,
            transparent: false, // Wy≈ÇƒÖczone - zapobiega "duchom" / nak≈Çadaniu warstw
            toneMapped: false // Wa≈ºne: ignoruje tone mapping, zachowuje oryginalne kolory
        });

        const screenMaterials = [panelMat, panelMat, panelMat, panelMat, screenFrontMat, panelMat];
        const screen = new THREE.Mesh(screenGeo, screenMaterials);
        // Pozycja Y zaktualizowana: 0.4 (podest) + 3.2 (po≈Çowa wysoko≈õci) = 3.6
        screen.position.set(0, 3.6, -2.5 - screenDepth / 2);
        scene.add(screen);

        const bounceLight = new THREE.RectAreaLight(0x2fc7ff, 6.0, screenWidth, screenHeight);
        bounceLight.position.set(0, 3.6, -2.4);
        bounceLight.lookAt(0, 1.0, 2.0);
        bounceLight.rotation.y = Math.PI;
        scene.add(bounceLight);

        // === SZKLANY PODEST ===
        const platformWidth = screenWidth;
        const platformDepth = 3.0;
        const platformHeight = 0.4; // Podwy≈ºszony podest
        const platformGeo = new THREE.BoxGeometry(platformWidth, platformHeight, platformDepth);

        const platformMat = new THREE.MeshStandardMaterial({
            color: 0x080808, // Prawie czarny, lekko widoczny
            roughness: 0.8,
            metalness: 0.2
        });

        const platform = new THREE.Mesh(platformGeo, platformMat);
        // Pozycja: ≈örodek podestu = -2.5 + 1.5 = -1.0 (styka siƒô z ekranem)
        platform.position.set(0, platformHeight / 2, -1.0);
        scene.add(platform);

        // === SYSTEM CZƒÑSTECZKOWY (Hologram) ===


        let particleSystem;
        // const clock usuwamy stƒÖd


        function initParticleText() {
            const isMobile = window.innerWidth < 768;
            const pointMultiplier = isMobile ? 400.0 : 300.0;
            const alphaBoost = isMobile ? "0.8" : "1.0";

            const vertexShader = `
            uniform float uTime, uProgress, uShineProgress, uGlobalAlpha; uniform vec2 uMouse;
            attribute vec3 aRandomPosition; attribute float aSize;
            varying vec3 vColor; varying float vAlpha;
            void main() {
                float t = smoothstep(0.0, 1.0, uProgress);
                vec3 currentPos = mix(aRandomPosition, position, t);
                
                if (uProgress > 0.9) { 
                    float dist = distance(currentPos.xz, uMouse * 4.0);
                    if (dist < 1.0) {
                        currentPos.y += (1.0 - dist) * 0.1;
                    }
                }

                vec4 mvPosition = modelViewMatrix * vec4(currentPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                gl_PointSize = aSize * (${pointMultiplier.toFixed(1)} / -mvPosition.z);
                
                float mixFactor = (position.z + 2.0) * 0.25;
                vec3 cyan = vec3(0.0, 1.0, 1.0);
                vec3 white = vec3(1.0, 1.0, 1.0);
                vec3 baseColor = mix(cyan, white, mixFactor);
                
                float sweepPos = mix(-5.0, 5.0, uShineProgress);
                float distX = abs(currentPos.x - sweepPos);
                float shine = smoothstep(1.0, 0.0, distX);
                vec3 gold = vec3(1.0, 0.85, 0.4);
                
                vColor = baseColor + (gold * shine * 1.2);
                vAlpha = smoothstep(0.0, 0.2, uProgress) * uGlobalAlpha * ${alphaBoost};
            }`;

            const fragmentShader = `
            varying vec3 vColor; varying float vAlpha;
            void main() {
                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = length(coord);
                if (dist > 0.5) discard;
                float strength = pow(1.0 - (dist * 2.0), 2.0);
                gl_FragColor = vec4(vColor, strength * vAlpha);
            }`;

            const canvas = document.createElement('canvas');
            canvas.width = 2048; canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            ctx.font = 'bold 350px sans-serif';
            ctx.fillText("FlowAssist", canvas.width / 2, canvas.height / 2 - 100);

            ctx.font = 'bold 200px sans-serif';
            ctx.fillText("Smart Business", canvas.width / 2, canvas.height / 2 + 150);

            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height), data = imgData.data;

            const targetPositions = [];
            const randomPositions = [];
            const sizes = [];

            // Skala zmniejszona o 10% (z 0.0020 na 0.0018)
            const scale = 0.0018;
            // Przesuniƒôcie w g≈ÇƒÖb sceny, aby napis by≈Ç na ≈õrodku podestu (pod drzewem)
            // Zmieniono na -0.2, aby 'obni≈ºyƒá' napis (przesunƒÖƒá w stronƒô kamery)
            const zOffset = -0.2;

            for (let y = 0; y < canvas.height; y += 2) {
                for (let x = 0; x < canvas.width; x += 2) {
                    const i = (y * canvas.width + x) * 4;
                    if (data[i + 3] > 128) {
                        const pX = (x - canvas.width / 2) * scale;
                        const pZ = (y - canvas.height / 2) * scale;
                        const pY = 0.45;

                        targetPositions.push(pX, pY, pZ + zOffset);
                        randomPositions.push(
                            (Math.random() - 0.5) * 5.0,
                            1.0 + Math.random() * 3.0,
                            (Math.random() - 0.5) * 5.0
                        );
                        sizes.push(Math.random() * 0.03 + 0.01);
                    }
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(targetPositions, 3));
            geometry.setAttribute('aRandomPosition', new THREE.Float32BufferAttribute(randomPositions, 3));
            geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                vertexShader, fragmentShader,
                uniforms: {
                    uTime: { value: 0 },
                    uProgress: { value: 0 },
                    uShineProgress: { value: 0 },
                    uGlobalAlpha: { value: 1.0 },
                    uMouse: { value: new THREE.Vector2(0, 0) }
                },
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            particleSystem.rotation.x = 0.35;
            particleSystem.position.set(0, 0.3, 0.5);
            scene.add(particleSystem);
        }

        initParticleText();


        // T≈Ço (Niebo) usuniƒôte (Void Stage)



        const mouse = new THREE.Vector2();
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        // 6. Konfiguracja GUI
        const visibilityFolder = gui.addFolder('Intensywno≈õƒá Element√≥w');

        // Logika restartu animacji
        let animationStartTime = 0;
        const animControl = {
            restart: () => {
                animationStartTime = clock.getElapsedTime();
                if (particleSystem) {
                    particleSystem.material.uniforms.uGlobalAlpha.value = 1.0;
                }
            }
        };
        gui.add(animControl, 'restart').name('‚ñ∂ Restart Animacji');

        // === KINEMATIC CAMERA MOVE (CRANE TILT-DOWN) ===
        // === KINEMATIC CAMERA MOVE (CRANE TILT-DOWN) ===
        function triggerCraneSequence() {
            // Czekamy a≈º napis siƒô uformuje (ok 2.5s)

            // Punkt docelowy kamery (Nalot) - Ustawione na sztywno wg ≈ºyczenia u≈ºytkownika
            const targetCamPos = isMobile
                ? { x: 0.00, y: 6.54, z: 3.58 } // Mobile: FINAL SETTINGS
                : { x: 0, y: 3.6, z: 9.0 };     // Desktop: Bez zmian (lub dopasuj je≈õli trzeba)

            // Punkt skupienia (LookAt)
            const targetFocus = isMobile
                ? { x: -0.03, y: 3.45, z: -0.69 } // Mobile: FINAL SETTINGS
                : { x: 0, y: 2.2, z: -1.0 };      // Desktop

            const delay = 3.0; // Start po uformowaniu napisu

            const tl = gsap.timeline({ delay: delay });

            // 1. INTENSYWNY BLASK (SHINE) PODCZAS LOTU
            // Zwiƒôkszamy alphaBoost i shine w trakcie lotu, potem wracamy do normy
            if (particleSystem) {
                // Skok jasno≈õci na start lotu
                tl.to(particleSystem.material.uniforms.uGlobalAlpha, {
                    value: 2.0, // Prze≈õwietlenie (o≈õlepiajƒÖce)
                    duration: 1.0,
                    ease: "power2.in"
                }, "start");

                // Powr√≥t do normalno≈õci po wylƒÖdowaniu
                tl.to(particleSystem.material.uniforms.uGlobalAlpha, {
                    value: isMobile ? 0.8 : 1.0, // Powr√≥t do standardowej czytelno≈õci
                    duration: 2.0,
                    ease: "power2.out"
                }, "end-=1.0"); // Zaczyna wracaƒá chwilƒô przed ko≈Ñcem lotu
            }

            // 2. Ruch Kamery (Position)
            tl.to(camera.position, {
                x: targetCamPos.x,
                y: targetCamPos.y,
                z: targetCamPos.z,
                duration: 5.0,
                ease: "power3.out",
            }, "start");

            // 3. Ruch Celu (LookAt / Rotation)
            tl.to(controls.target, {
                x: targetFocus.x,
                y: targetFocus.y,
                z: targetFocus.z,
                duration: 5.0,
                ease: "power3.out",
                onUpdate: () => {
                    controls.update();
                }
            }, "start");

            tl.addLabel("end");
        }

        // Uruchom sekwencjƒô (przeniesione na koniec pliku, aby nie blokowaƒá GUI w razie b≈Çƒôdu)
        // triggerCraneSequence();



        visibilityFolder.add({ logoOpacity: 100 }, 'logoOpacity', 0, 100, 1).name('Logo (Drzewo) %').onChange((value) => {
            screenFrontMat.opacity = value / 100;
            screen.visible = value > 0;
        });

        const textParams = {
            duration: 1000,
            fadeOutStart: 12.01,
            manualFade: false
        };

        visibilityFolder.add(textParams, 'fadeOutStart', 0, 20).name('Zniknij po (s)');

        visibilityFolder.add({
            toggle: () => {
                if (!particleSystem) return;
                textParams.manualFade = !textParams.manualFade;
            }
        }, 'toggle').name('Poka≈º/Ukryj Napis');

        const lightFolder = gui.addFolder('O≈õwietlenie Studyjne');
        lightFolder.add(keyLight, 'intensity', 0, 5).name('≈öwiat≈Ço Kluczowe');
        lightFolder.add(fillLight, 'intensity', 0, 2).name('≈öwiat≈Ço Wype≈ÇniajƒÖce');
        lightFolder.add(rimLight, 'intensity', 0, 2).name('≈öwiat≈Ço Tylne (Rim)');
        lightFolder.add(bounceLight, 'intensity', 0, 10).name('Odbicie od Ekranu');
        lightFolder.add(hemiLight, 'intensity', 0, 1).name('≈öwiat≈Ço Otoczenia');

        const bloomFolder = gui.addFolder('Efekt Po≈õwiaty (Bloom)');
        bloomFolder.add(bloomPass, 'threshold', 0, 1).name('Pr√≥g Jasno≈õci');
        bloomFolder.add(bloomPass, 'strength', 0, 5).name('Intensywno≈õƒá');
        bloomFolder.add(bloomPass, 'radius', 0, 2).name('Promie≈Ñ Rozmycia');





        // Pƒôtla animacji
        function animate() {
            requestAnimationFrame(animate);
            const globalTime = clock.getElapsedTime();
            const time = globalTime - animationStartTime; // Czas lokalny dla animacji

            if (particleSystem) {
                particleSystem.material.uniforms.uTime.value = time;
                particleSystem.material.uniforms.uMouse.value.copy(mouse);

                // Animacja wej≈õcia (0 do 2.5s)
                let progress = Math.min(time * 0.4, 1.0);
                particleSystem.material.uniforms.uProgress.value = progress;

                // Efekt Shine (cykliczny co jaki≈õ czas)
                if (progress >= 1.0) {
                    // Shine co 5 sekund
                    let shineTime = (time - 2.5) % 5.0;
                    if (shineTime < 1.0) {
                        particleSystem.material.uniforms.uShineProgress.value = shineTime;
                    } else {
                        particleSystem.material.uniforms.uShineProgress.value = -1.0; // poza zakresem
                    }
                }

                // Animacja ZNIKANIA (Fade Out) kontrolowana przez suwak
                let targetAlpha = 1.0;

                // FORMATION GLOW: Mocne ≈õwiecenie podczas formowania napisu
                if (progress < 1.0) {
                    targetAlpha = 3.0; // Intensywne ≈ºarzenie siƒô czƒÖsteczek podczas lotu
                } else if (time > textParams.fadeOutStart && !textParams.manualFade) {
                    targetAlpha = 0.0;
                } else if (textParams.manualFade) {
                    targetAlpha = 0.0;
                }

                particleSystem.material.uniforms.uGlobalAlpha.value = THREE.MathUtils.lerp(
                    particleSystem.material.uniforms.uGlobalAlpha.value,
                    targetAlpha,
                    0.05
                );
            } // Zamkniƒôcie if (particleSystem)

            controls.update();
            composer.render();
        }
        animate();





        // Uruchomienie sekwencji animacji (bezpiecznie)
        try {
            setTimeout(() => {
                if (typeof triggerCraneSequence === 'function') {
                    triggerCraneSequence();
                }
            }, 100);
        } catch (e) {
            console.error("Animation Sequence Error:", e);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
    <video id="promoVideo" style="display:none;"></video>
</body>

</html>