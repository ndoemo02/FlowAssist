<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>FreeFlowXR ‚Äì Panel Deweloperski</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Inter', sans-serif;
        }

        nav {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 1000;
            padding: 20px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8), transparent);
            box-sizing: border-box;
        }

        .logo {
            color: white;
            font-weight: bold;
            font-size: 20px;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo img {
            height: 30px;
        }

        .menu {
            display: flex;
            gap: 30px;
        }

        .menu a {
            color: rgba(255, 255, 255, 0.7);
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            transition: color 0.3s ease;
        }

        .menu a:hover,
        .menu a.active {
            color: white;
        }

        .back-btn {
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            color: white;
            text-decoration: none;
            font-size: 14px;
            transition: all 0.3s;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: white;
        }

        #debug-toggle {
            display: none;
        }

        @media (max-width: 768px) {
            nav {
                padding: 15px;
                flex-direction: column;
                gap: 15px;
                background: linear-gradient(to bottom, rgba(0, 0, 0, 0.9), transparent);
            }

            .menu {
                width: 100%;
                justify-content: center;
                gap: 20px;
            }

            .logo {
                margin-bottom: 5px;
            }

            /* Ukrywamy panel deweloperski na mobile, bo zas≈Çania widok */
            /* Ukrywamy panel deweloperski na mobile DOMY≈öLNIE, ale pozwalamy go w≈ÇƒÖczyƒá */
            .lil-gui {
                display: none;
                /* Bƒôdzie sterowane przez JS */
            }

            #debug-toggle {
                position: fixed;
                bottom: 20px;
                left: 20px;
                width: 40px;
                height: 40px;
                background: rgba(0, 0, 0, 0.6);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 50%;
                color: white;
                font-size: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 2000;
                cursor: pointer;
            }
        }
    </style>
    <div id="debug-toggle">‚öôÔ∏è</div>
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.161/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161/examples/jsm/", "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.5/index.js" } }
    </script>
</head>

<body>
    <nav>
        <a href="/" class="logo">
            <img src="/logo_header.png" alt="Logo">
        </a>
        <div class="menu">
            <a href="#" class="active">Technologia</a>
            <a href="/dev/v5">Studio V5</a>
            <a href="/?view=map">Maps plan</a>
            <a href="/contact">Kontakt</a>
        </div>
        <a href="/dev/v5" class="back-btn">‚Üí Studio V5</a>
    </nav>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import gsap from 'gsap';

        // 1. Inicjalizacja GUI
        const gui = new GUI({ title: 'Panel Deweloperski' });

        // Debug Toggle Logic
        const debugToggle = document.getElementById('debug-toggle');
        let isDebugVisible = false;

        if (window.innerWidth < 768) {
            debugToggle.style.display = 'flex';
            gui.domElement.style.display = 'none'; // Start hidden on mobile
        }

        debugToggle.addEventListener('click', () => {
            isDebugVisible = !isDebugVisible;
            gui.domElement.style.display = isDebugVisible ? 'block' : 'none';
        });

        // === PRIORITY DEBUG BUTTONS (Added first to ensure visibility) ===
        const camFolder = gui.addFolder('Ustawienia Kamery (DEBUG)');
        // Will populate this folder after camera is created


        // 2. Scena, Kamera, Renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        // scene.fog usuniƒôta dla efektu void
        const clock = new THREE.Clock(); // G≈Ç√≥wny zegar sceny

        // Dostosowanie FOV dla mobile (szerszy kƒÖt w pionie)
        const isMobile = window.innerWidth < 768;
        const initialFov = isMobile ? 60 : 35;

        const camera = new THREE.PerspectiveCamera(initialFov, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 2.485996, 6.13);
        camera.rotation.x = -0.38;

        // Korekta pozycji kamery na mobile (wy≈ºej i dalej)
        if (isMobile) {
            camera.position.set(0, 3.5, 10.0);
            camera.rotation.x = -0.25;
        }

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Ograniczenie DPR do 2.0 (wy≈ºsza jako≈õƒá)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.6;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // 3. Kontrolery i Post-processing
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1.2, 0);
        controls.enableDamping = true;
        controls.minDistance = 2;
        controls.maxDistance = 8;
        controls.maxPolarAngle = Math.PI * 0.85;
        controls.minPolarAngle = Math.PI * 0.1;

        // === POPULATE CAMERA DEBUG (Now that camera & controls exist) ===
        const debugParams = {
            logCoords: () => {
                const info = `
Camera POS: x:${camera.position.x.toFixed(2)}, y:${camera.position.y.toFixed(2)}, z:${camera.position.z.toFixed(2)}
Target LOOK: x:${controls.target.x.toFixed(2)}, y:${controls.target.y.toFixed(2)}, z:${controls.target.z.toFixed(2)}
                `;
                console.log(info);
                alert(info);
            }
        };

        camFolder.add(camera.position, 'x', -10, 10).name('Cam X').listen();
        camFolder.add(camera.position, 'y', 0, 20).name('Cam Y').listen();
        camFolder.add(camera.position, 'z', 0, 25).name('Cam Z').listen();

        camFolder.add(controls.target, 'x', -5, 5).name('LookAt X').listen().onChange(() => controls.update());
        camFolder.add(controls.target, 'y', -5, 10).name('LookAt Y').listen().onChange(() => controls.update());
        camFolder.add(controls.target, 'z', -10, 10).name('LookAt Z').listen().onChange(() => controls.update());

        camFolder.add(debugParams, 'logCoords').name('üìã LOG COORDINATES');
        camFolder.open();

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 1;
        bloomPass.strength = 1.833;
        bloomPass.radius = 0;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // 4. ≈öwiat≈Ça
        RectAreaLightUniformsLib.init();

        const keyLight = new THREE.RectAreaLight(0xffffff, 0, 2, 4);
        keyLight.position.set(-2.5, 2.5, 2.5);
        keyLight.lookAt(0, 1.0, 0);
        scene.add(keyLight);

        const fillLight = new THREE.SpotLight(0xffffff, 0);
        fillLight.position.set(3, 2, 2);
        fillLight.angle = Math.PI / 4;
        fillLight.penumbra = 1;
        fillLight.castShadow = true;
        scene.add(fillLight);

        const rimLight = new THREE.SpotLight(0x3ac8ff, 2);
        rimLight.position.set(0, 2.2, -3);
        rimLight.lookAt(0, 1.0, 0);
        rimLight.penumbra = 0.5;
        scene.add(rimLight);

        // bounceLight ju≈º jest zadeklarowane p√≥≈∫niej, ale tutaj by≈Çy definicje innych ≈õwiate≈Ç.
        // Czekaj, bounceLight jest osobno w linii 134. Tutaj zmieniamy tylko key, fill, rim.

        const hemiLight = new THREE.HemisphereLight(0x222222, 0x000000, 0);
        scene.add(hemiLight);

        // 5. Obiekty Sceny
        const textureLoader = new THREE.TextureLoader();

        // Pod≈Çoga
        const floorGeo = new THREE.PlaneGeometry(10, 10);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4, metalness: 0.2 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Pok√≥j i sufit usuniƒôte (Void Stage)

        // Ekran (Drzewo Video w jako≈õci HD) - PODWY≈ªSZONY DLA PIONOWEGO WIDEO
        const screenWidth = 4.8, screenHeight = 6.4, screenDepth = 1.2;

        const screenGeo = new THREE.BoxGeometry(screenWidth, screenHeight, screenDepth);

        // === WIDEO LOGO (Drzewo) ===
        const logoVideo = document.createElement('video');
        logoVideo.src = '/assets/video/drzewo%20video.mp4';
        logoVideo.loop = true;
        logoVideo.muted = true;
        logoVideo.playsInline = true;
        logoVideo.crossOrigin = 'anonymous';
        logoVideo.play();

        const treeTexture = new THREE.VideoTexture(logoVideo);
        treeTexture.minFilter = THREE.LinearFilter;
        treeTexture.magFilter = THREE.LinearFilter;
        treeTexture.colorSpace = THREE.SRGBColorSpace;

        // Zapobieganie rozciƒÖganiu na ca≈ÇƒÖ szeroko≈õƒá (centrowanie pionowego wideo)
        logoVideo.addEventListener('loadedmetadata', () => {
            const videoAspect = logoVideo.videoWidth / logoVideo.videoHeight;
            const screenAspect = screenWidth / screenHeight;

            if (videoAspect < screenAspect) {
                // Wideo jest bardziej pionowe ni≈º ekran - dodajemy "pasy" po bokach
                const repeatX = screenAspect / videoAspect;
                treeTexture.repeat.set(repeatX, 1);
                treeTexture.offset.set((1 - repeatX) / 2, 0);
            } else {
                // Wideo jest szersze - dodajemy pasy g√≥ra/d√≥≈Ç (choƒá tu celujemy w pionowe)
                const repeatY = videoAspect / screenAspect;
                treeTexture.repeat.set(1, repeatY);
                treeTexture.offset.set(0, (1 - repeatY) / 2);
            }
        });

        // BasicMaterial zapewnia brak cieniowania (samo≈õwiecenie) = realna jako≈õƒá grafiki
        const panelMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const screenFrontMat = new THREE.MeshBasicMaterial({
            map: treeTexture,
            transparent: true,
            toneMapped: false // Wa≈ºne: ignoruje tone mapping, zachowuje oryginalne kolory
        });

        const screenMaterials = [panelMat, panelMat, panelMat, panelMat, screenFrontMat, panelMat];
        const screen = new THREE.Mesh(screenGeo, screenMaterials);
        // Pozycja Y zaktualizowana: 0.4 (podest) + 3.2 (po≈Çowa wysoko≈õci) = 3.6
        screen.position.set(0, 3.6, -2.5 - screenDepth / 2);
        scene.add(screen);

        const bounceLight = new THREE.RectAreaLight(0x2fc7ff, 6.0, screenWidth, screenHeight);
        bounceLight.position.set(0, 3.6, -2.4);
        bounceLight.lookAt(0, 1.0, 2.0);
        bounceLight.rotation.y = Math.PI;
        scene.add(bounceLight);

        // === SZKLANY PODEST ===
        const platformWidth = screenWidth;
        const platformDepth = 3.0;
        const platformHeight = 0.4; // Podwy≈ºszony podest
        const platformGeo = new THREE.BoxGeometry(platformWidth, platformHeight, platformDepth);

        const platformMat = new THREE.MeshStandardMaterial({
            color: 0x080808, // Prawie czarny, lekko widoczny
            roughness: 0.8,
            metalness: 0.2
        });

        const platform = new THREE.Mesh(platformGeo, platformMat);
        // Pozycja: ≈örodek podestu = -2.5 + 1.5 = -1.0 (styka siƒô z ekranem)
        platform.position.set(0, platformHeight / 2, -1.0);
        scene.add(platform);

        // === SYSTEM CZƒÑSTECZKOWY (Hologram) ===


        let particleSystem;
        // const clock usuwamy stƒÖd


        function initParticleText() {
            const isMobile = window.innerWidth < 768;
            const pointMultiplier = isMobile ? 400.0 : 300.0;
            const alphaBoost = isMobile ? "0.8" : "1.0";

            const vertexShader = `
            uniform float uTime, uProgress, uShineProgress, uGlobalAlpha; uniform vec2 uMouse;
            attribute vec3 aRandomPosition; attribute float aSize;
            varying vec3 vColor; varying float vAlpha;
            void main() {
                float t = smoothstep(0.0, 1.0, uProgress);
                vec3 currentPos = mix(aRandomPosition, position, t);
                
                if (uProgress > 0.9) { 
                    float dist = distance(currentPos.xz, uMouse * 4.0);
                    if (dist < 1.0) {
                        currentPos.y += (1.0 - dist) * 0.1;
                    }
                }

                vec4 mvPosition = modelViewMatrix * vec4(currentPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                gl_PointSize = aSize * (${pointMultiplier.toFixed(1)} / -mvPosition.z);
                
                float mixFactor = (position.z + 2.0) * 0.25;
                vec3 cyan = vec3(0.0, 1.0, 1.0);
                vec3 white = vec3(1.0, 1.0, 1.0);
                vec3 baseColor = mix(cyan, white, mixFactor);
                
                float sweepPos = mix(-5.0, 5.0, uShineProgress);
                float distX = abs(currentPos.x - sweepPos);
                float shine = smoothstep(1.0, 0.0, distX);
                vec3 gold = vec3(1.0, 0.85, 0.4);
                
                vColor = baseColor + (gold * shine * 1.2);
                vAlpha = smoothstep(0.0, 0.2, uProgress) * uGlobalAlpha * ${alphaBoost};
            }`;

            const fragmentShader = `
            varying vec3 vColor; varying float vAlpha;
            void main() {
                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = length(coord);
                if (dist > 0.5) discard;
                float strength = pow(1.0 - (dist * 2.0), 2.0);
                gl_FragColor = vec4(vColor, strength * vAlpha);
            }`;

            const canvas = document.createElement('canvas');
            canvas.width = 2048; canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            ctx.font = 'bold 350px sans-serif';
            ctx.fillText("FlowAssist", canvas.width / 2, canvas.height / 2 - 100);

            ctx.font = 'bold 200px sans-serif';
            ctx.fillText("Smart Business", canvas.width / 2, canvas.height / 2 + 150);

            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height), data = imgData.data;

            const targetPositions = [];
            const randomPositions = [];
            const sizes = [];

            // Skala zmniejszona o 10% (z 0.0020 na 0.0018)
            const scale = 0.0018;
            // Przesuniƒôcie w g≈ÇƒÖb sceny, aby napis by≈Ç na ≈õrodku podestu (pod drzewem)
            // Zmieniono na -0.2, aby 'obni≈ºyƒá' napis (przesunƒÖƒá w stronƒô kamery)
            const zOffset = -0.2;

            for (let y = 0; y < canvas.height; y += 2) {
                for (let x = 0; x < canvas.width; x += 2) {
                    const i = (y * canvas.width + x) * 4;
                    if (data[i + 3] > 128) {
                        const pX = (x - canvas.width / 2) * scale;
                        const pZ = (y - canvas.height / 2) * scale;
                        const pY = 0.45;

                        targetPositions.push(pX, pY, pZ + zOffset);
                        randomPositions.push(
                            (Math.random() - 0.5) * 5.0,
                            1.0 + Math.random() * 3.0,
                            (Math.random() - 0.5) * 5.0
                        );
                        sizes.push(Math.random() * 0.03 + 0.01);
                    }
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(targetPositions, 3));
            geometry.setAttribute('aRandomPosition', new THREE.Float32BufferAttribute(randomPositions, 3));
            geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                vertexShader, fragmentShader,
                uniforms: {
                    uTime: { value: 0 },
                    uProgress: { value: 0 },
                    uShineProgress: { value: 0 },
                    uGlobalAlpha: { value: 1.0 },
                    uMouse: { value: new THREE.Vector2(0, 0) }
                },
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            particleSystem.rotation.x = 0.35;
            particleSystem.position.set(0, 0.3, 0.5);
            scene.add(particleSystem);
        }

        initParticleText();


        // T≈Ço (Niebo) usuniƒôte (Void Stage)



        const mouse = new THREE.Vector2();
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        // 6. Konfiguracja GUI
        const visibilityFolder = gui.addFolder('Intensywno≈õƒá Element√≥w');

        // Logika restartu animacji
        let animationStartTime = 0;
        const animControl = {
            restart: () => {
                animationStartTime = clock.getElapsedTime();
                if (particleSystem) {
                    particleSystem.material.uniforms.uGlobalAlpha.value = 1.0;
                }
            }
        };
        gui.add(animControl, 'restart').name('‚ñ∂ Restart Animacji');

        // === KINEMATIC CAMERA MOVE (CRANE TILT-DOWN) ===
        function triggerCraneSequence() {
            // Czekamy a≈º napis siƒô uformuje (ok 2.5s)

            // Punkt docelowy kamery (Nalot)
            // Zmiana: "Eye level" z drzewem. Mniej "z g√≥ry", bardziej na wprost.
            // Screen center Y = 3.6. Camera Y ~ 3.8 (lekko nad ≈õrodkiem).
            // Zwiƒôkszamy dystans (Z), aby zmie≈õciƒá ca≈Çy pionowy ekran (6.4m).
            const targetCamPos = isMobile
                ? { x: 0, y: 3.8, z: 11.5 } // Mobile: Daleko, na wprost ≈õrodka ekranu
                : { x: 0, y: 3.6, z: 9.0 }; // Desktop: Wywa≈ºony kadr

            // Punkt skupienia (LookAt)
            // Celujemy w dolnƒÖ czƒô≈õƒá pnia/korzenie (Y ~ 2.2), to wy≈õrodkuje kompozycjƒô
            // (Drzewo g√≥ra + Napis d√≥≈Ç).
            const targetFocus = { x: 0, y: 2.2, z: -1.0 };

            const delay = 3.0; // Start po uformowaniu napisu

            const tl = gsap.timeline({ delay: delay });

            // 1. Ruch Kamery (Position)
            tl.to(camera.position, {
                x: targetCamPos.x,
                y: targetCamPos.y,
                z: targetCamPos.z,
                duration: 5.0,
                ease: "power3.out", // Cubic/Quartic feel
                onUpdate: () => {
                    // Opcjonalnie: dynamiczna korekta lookAt w trakcie lotu,
                    // ale lepiej animowaƒá orbitControls.target
                }
            }, "start");

            // 2. Ruch Celu (LookAt / Rotation)
            // OrbitControls.target determinuje gdzie patrzy kamera.
            tl.to(controls.target, {
                x: targetFocus.x,
                y: targetFocus.y,
                z: targetFocus.z,
                duration: 5.0,
                ease: "power3.out",
                onUpdate: () => {
                    controls.update(); // Wa≈ºne dla synchronizacji ≈õwiat≈Ça kamery
                }
            }, "start");
        }

        // Uruchom sekwencjƒô (przeniesione na koniec pliku, aby nie blokowaƒá GUI w razie b≈Çƒôdu)
        // triggerCraneSequence();



        visibilityFolder.add({ logoOpacity: 100 }, 'logoOpacity', 0, 100, 1).name('Logo (Drzewo) %').onChange((value) => {
            screenFrontMat.opacity = value / 100;
            screen.visible = value > 0;
        });

        const textParams = {
            duration: 1000,
            fadeOutStart: 12.01,
            manualFade: false
        };

        visibilityFolder.add(textParams, 'fadeOutStart', 0, 20).name('Zniknij po (s)');

        visibilityFolder.add({
            toggle: () => {
                if (!particleSystem) return;
                textParams.manualFade = !textParams.manualFade;
            }
        }, 'toggle').name('Poka≈º/Ukryj Napis');

        const lightFolder = gui.addFolder('O≈õwietlenie Studyjne');
        lightFolder.add(keyLight, 'intensity', 0, 5).name('≈öwiat≈Ço Kluczowe');
        lightFolder.add(fillLight, 'intensity', 0, 2).name('≈öwiat≈Ço Wype≈ÇniajƒÖce');
        lightFolder.add(rimLight, 'intensity', 0, 2).name('≈öwiat≈Ço Tylne (Rim)');
        lightFolder.add(bounceLight, 'intensity', 0, 10).name('Odbicie od Ekranu');
        lightFolder.add(hemiLight, 'intensity', 0, 1).name('≈öwiat≈Ço Otoczenia');

        const bloomFolder = gui.addFolder('Efekt Po≈õwiaty (Bloom)');
        bloomFolder.add(bloomPass, 'threshold', 0, 1).name('Pr√≥g Jasno≈õci');
        bloomFolder.add(bloomPass, 'strength', 0, 5).name('Intensywno≈õƒá');
        bloomFolder.add(bloomPass, 'radius', 0, 2).name('Promie≈Ñ Rozmycia');





        // Pƒôtla animacji
        function animate() {
            requestAnimationFrame(animate);
            const globalTime = clock.getElapsedTime();
            const time = globalTime - animationStartTime; // Czas lokalny dla animacji

            if (particleSystem) {
                particleSystem.material.uniforms.uTime.value = time;
                particleSystem.material.uniforms.uMouse.value.copy(mouse);

                // Animacja wej≈õcia (0 do 2.5s)
                let progress = Math.min(time * 0.4, 1.0);
                particleSystem.material.uniforms.uProgress.value = progress;

                // Efekt Shine (cykliczny co jaki≈õ czas)
                if (progress >= 1.0) {
                    // Shine co 5 sekund
                    let shineTime = (time - 2.5) % 5.0;
                    if (shineTime < 1.0) {
                        particleSystem.material.uniforms.uShineProgress.value = shineTime;
                    } else {
                        particleSystem.material.uniforms.uShineProgress.value = -1.0; // poza zakresem
                    }
                }

                // Animacja ZNIKANIA (Fade Out) kontrolowana przez suwak
                let targetAlpha = 1.0;
                if (time > textParams.fadeOutStart && !textParams.manualFade) {
                    targetAlpha = 0.0;
                } else if (textParams.manualFade) {
                    targetAlpha = 0.0;
                }

                particleSystem.material.uniforms.uGlobalAlpha.value = THREE.MathUtils.lerp(
                    particleSystem.material.uniforms.uGlobalAlpha.value,
                    targetAlpha,
                    0.05
                );
            } // Zamkniƒôcie if (particleSystem)

            controls.update();
            composer.render();
        }
        animate();

        // 7. WIDEO PROMOCYJNE (Po lewej od logo)
        const video = document.createElement('video');
        video.src = '/assets/video/flowassist-promo.mp4';
        video.loop = true;
        video.muted = true;
        video.playsInline = true;
        video.crossOrigin = 'anonymous';
        video.play();

        const videoTexture = new THREE.VideoTexture(video);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;
        videoTexture.colorSpace = THREE.SRGBColorSpace;

        // Startowa geometria (zostanie zaktualizowana)
        const videoGeo = new THREE.PlaneGeometry(1, 1);
        const videoMat = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide, transparent: true });
        const videoMesh = new THREE.Mesh(videoGeo, videoMat);

        // Pozycja poczƒÖtkowa
        videoMesh.position.set(-4.5, 1.75, -2.5);
        videoMesh.rotation.y = Math.PI * 0.1;
        scene.add(videoMesh);

        // Automatyczna korekta proporcji po za≈Çadowaniu wideo
        video.addEventListener('loadedmetadata', () => {
            const aspect = video.videoWidth / video.videoHeight;
            const height = 1.75; // Sta≈Ça wysoko≈õƒá
            const width = height * aspect;

            videoMesh.geometry.dispose();
            videoMesh.geometry = new THREE.PlaneGeometry(width, height);

            // PRZYBLI≈ªENIE MAKSYMALNE DO EKRANU
            // Krawƒôd≈∫ ekranu (drzewa) jest na X = -2.4
            // Chcemy, by prawa krawƒôd≈∫ wideo dotyka≈Ça lewej krawƒôdzi ekranu (z minimalnym odstƒôpem)
            // X wideo = Krawƒôd≈∫ (-2.4) - Po≈Çowa szeroko≈õci wideo (width/2) - Margines (0.05)

            videoMesh.position.x = -2.4 - (width / 2) - 0.05;

            console.log(`Video updated. Pos X: ${videoMesh.position.x}, Size: ${width}x${height}`);
        });

        // Fix transparency artifacts
        videoMesh.renderOrder = 999;
        videoMat.depthWrite = false;

        // === PRZYCISK D≈πWIƒòKU ===
        const soundBtn = document.createElement('button');
        soundBtn.textContent = 'üîä W≈ÇƒÖcz d≈∫wiƒôk';
        soundBtn.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 24px;
            background: rgba(0,0,0,0.8);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 30px;
            font-size: 14px;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s;
        `;
        soundBtn.onmouseover = () => soundBtn.style.background = 'rgba(50,50,50,0.9)';
        soundBtn.onmouseout = () => soundBtn.style.background = 'rgba(0,0,0,0.8)';
        document.body.appendChild(soundBtn);

        soundBtn.addEventListener('click', () => {
            video.muted = false;
            video.volume = 0.7;
            if (video.paused) video.play();
            soundBtn.remove();
        });

        // Uruchomienie sekwencji animacji (bezpiecznie)
        try {
            setTimeout(() => {
                if (typeof triggerCraneSequence === 'function') {
                    triggerCraneSequence();
                }
            }, 100);
        } catch (e) {
            console.error("Animation Sequence Error:", e);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
    <video id="promoVideo" style="display:none;"></video>
</body>

</html>